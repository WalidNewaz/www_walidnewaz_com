{
  "topic": "Advanced Object-Oriented Programming in Python",
  "questions": [
    {
      "question": "Which of the following Python data structures maintains insertion order and is mutable?",
      "options": [
        {
          "text": "tuple",
          "correct": false,
          "explanation": "Tuples are immutable and do not support item assignment."
        },
        {
          "text": "list",
          "correct": true,
          "explanation": "Lists are ordered, mutable collections in Python."
        },
        {
          "text": "set",
          "correct": false,
          "explanation": "Sets do not guarantee insertion order prior to Python 3.7 and are unordered by design."
        },
        {
          "text": "frozenset",
          "correct": false,
          "explanation": "Frozensets are immutable and unordered."
        }
      ]
    },
    {
      "question": "What is the time complexity of accessing the first item of a list in Python using indexing (e.g., lst[0])?",
      "options": [
        {
          "text": "O(n)",
          "correct": false,
          "explanation": "O(n) would imply linear search, which does not apply to direct indexing."
        },
        {
          "text": "O(log n)",
          "correct": false,
          "explanation": "Binary search takes O(log n), not simple indexing."
        },
        {
          "text": "O(1)",
          "correct": true,
          "explanation": "Direct access by index is a constant-time operation in Python lists."
        },
        {
          "text": "O(n^2)",
          "correct": false,
          "explanation": "Quadratic time would apply to nested loops, not indexing."
        }
      ]
    },
    {
      "question": "True or False: Bubble sort is a good choice for large datasets due to its average time complexity of O(n log n).",
      "options": [
        {
          "text": "True",
          "correct": false,
          "explanation": "Bubble sort has average and worst-case time complexity of O(n²), which is inefficient for large datasets."
        },
        {
          "text": "False",
          "correct": true,
          "explanation": "Bubble sort is generally inefficient for large datasets due to its O(n²) time complexity."
        }
      ]
    },
    {
      "question": "Which of the following statements about binary search is FALSE?",
      "options": [
        {
          "text": "It requires the input list to be sorted.",
          "correct": false,
          "explanation": "This is true. Binary search only works on sorted data."
        },
        {
          "text": "Its worst-case time complexity is O(log n).",
          "correct": false,
          "explanation": "This is correct; each step halves the search space."
        },
        {
          "text": "It always checks every element in the list.",
          "correct": true,
          "explanation": "False. Binary search checks a logarithmic number of elements, not all."
        },
        {
          "text": "Its space complexity is O(1) if implemented iteratively.",
          "correct": false,
          "explanation": "This is true for the iterative version."
        }
      ]
    },
    {
      "question": "Which Python standard library structure would you use for a thread-safe FIFO queue?",
      "options": [
        {
          "text": "deque",
          "correct": false,
          "explanation": "`deque` is efficient and supports FIFO operations but is not thread-safe by default."
        },
        {
          "text": "list",
          "correct": false,
          "explanation": "`list` is not thread-safe and can be inefficient for queue operations."
        },
        {
          "text": "queue.Queue",
          "correct": true,
          "explanation": "`queue.Queue` is a thread-safe FIFO queue implementation provided by the `queue` module."
        },
        {
          "text": "heapq",
          "correct": false,
          "explanation": "`heapq` is for priority queues, not FIFO, and is not thread-safe."
        }
      ]
    }
  ]
}
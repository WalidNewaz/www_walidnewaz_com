---
featured: false
date: "2024-01-05"

series: "Building a Blog Feedback System"
part: "III. Custom Full-Stack Feedback System"
chapter: "5. Building Your Own Feedback API"

title: "Building Your Own Feedback API"
description: "In this chapter we create our own feedback API along with a new React component to interact with the API."
has_quiz: true
tags: ["Feedback", "API", "Web Dev"]
---

# Chapter 5: Building Your Own Feedback API

So far we’ve used **Airtable** and **Giscus/Disqus** as external services. That works well for prototyping — but at some point, you’ll want more control:

* Storing data in **your own database**.
* Customizing the **API schema**.
* Integrating feedback with **dashboards** and **notifications**.

In this chapter, we’ll:

* Design a **feedback API schema**.
* Build it in **FastAPI (Python)**.
* Build the same in **NestJS (TypeScript)**.
* Connect it to a simple frontend widget (a drop-in React component).

## 5.1 Feedback Data Model

We’ll keep the schema minimal but extensible:

<MdxTable>
| Field      | Type          | Description                            |
| ---------- | ------------- | -------------------------------------- |
| id         | UUID / int    | Unique identifier                      |
| post_slug  | string        | Blog post identifier                   |
| helpful    | boolean/null  | Yes/No vote (optional if only comment) |
| comment    | string (text) | Optional reader comment                |
| created_at | timestamp     | Auto-generated                         |
</MdxTable>

Later, we can extend with user info, sentiment, moderation flags, etc.


## 5.2 FastAPI Implementation

### 5.2.1 Project Setup

```bash
mkdir fastapi-feedback && cd fastapi-feedback
python -m venv venv
source venv/bin/activate
pip install fastapi uvicorn sqlalchemy pydantic[dotenv] pytest
```

### 5.2.2 Database Schema (SQLite for dev)

```python
"""
@file: app/models.py
@showLineNumbers
@copy
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime
from sqlalchemy.ext.declarative import declarative_base
from datetime import datetime

Base = declarative_base()

class Feedback(Base):
    __tablename__ = "feedback"

    id = Column(Integer, primary_key=True, index=True)
    post_slug = Column(String, index=True)
    helpful = Column(Boolean, nullable=True)
    comment = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

### 5.2.3 FastAPI App

```python
"""
@file: app/main.py
@showLineNumbers
@copy
"""
from fastapi import FastAPI, Depends
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from app.models import Base, Feedback
from pydantic import BaseModel
from typing import Optional, List

DATABASE_URL = "sqlite:///./feedback.db"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine)

Base.metadata.create_all(bind=engine)

app = FastAPI(title="Feedback API")

def get_db():
    """Provide a database session to each request."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

class FeedbackCreate(BaseModel):
    """Schema for creating and returning feedback entries."""
    post_slug: str
    helpful: Optional[bool] = None
    comment: Optional[str] = None

@app.post("/feedback")
def create_feedback(data: FeedbackCreate, db: Session = Depends(get_db)):
    """Create a new feedback entry."""
    fb = Feedback(post_slug=data.post_slug, helpful=data.helpful, comment=data.comment)
    db.add(fb)
    db.commit()
    db.refresh(fb)
    return fb

@app.get("/feedback", response_model=List[FeedbackCreate])
def get_all_feedback(db: Session = Depends(get_db)):
    """Retrieve all feedback entries."""
    return db.query(Feedback).all()

@app.get("/feedback/{post_slug}", response_model=List[FeedbackCreate])
def get_feedback(post_slug: str, db: Session = Depends(get_db)):
    """Retrieve feedback for a specific post."""
    return db.query(Feedback).filter(Feedback.post_slug == post_slug).all()
```

### 5.2.4 Run the API

```bash
uvicorn app.main:app --reload
```

Now you have:

* `POST /feedback` → create feedback.
* `GET /feedback/{slug}` → list feedback for a post.

## 5.3 NestJS Implementation

### 5.3.1 Project Setup

```bash
npx @nestjs/cli new nest-feedback
cd nest-feedback
npm install @nestjs/typeorm typeorm sqlite3
```

### 5.3.2 Feedback Entity

```ts
/**
 * @file: src/feedback/feedback.entity.ts
 * @showLineNumbers
 */
import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn } from 'typeorm';

@Entity()
export class Feedback {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  postSlug: string;

  @Column({ nullable: true })
  helpful?: boolean;

  @Column({ nullable: true, type: 'text' })
  comment?: string;

  @CreateDateColumn()
  createdAt: Date;
}
```

### 5.3.3 Service &#10010; Controller

```ts
/**
 * @file: src/feedback/feedback.service.ts
 * @showLineNumbers
 */
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Feedback } from './feedback.entity';

@Injectable()
export class FeedbackService {
  constructor(
    @InjectRepository(Feedback) private repo: Repository<Feedback>,
  ) {}

  create(data: Partial<Feedback>): Promise<Feedback> {
    const fb = this.repo.create(data);
    return this.repo.save(fb);
  }

  findByPost(postSlug: string): Promise<Feedback[]> {
    return this.repo.find({ where: { postSlug } });
  }
}
```

```ts
/**
 * @file: src/feedback/feedback.controller.ts
 * @showLineNumbers
 */
import { Controller, Post, Get, Param, Body } from '@nestjs/common';
import { FeedbackService } from './feedback.service';
import { Feedback } from './feedback.entity';

@Controller('feedback')
export class FeedbackController {
  constructor(private readonly service: FeedbackService) {}

  @Post()
  create(@Body() data: Partial<Feedback>): Promise<Feedback> {
    return this.service.create(data);
  }

  @Get(':slug')
  find(@Param('slug') slug: string): Promise<Feedback[]> {
    return this.service.findByPost(slug);
  }
}
```

### 5.3.4 Module Setup

```ts
/**
 * @file: src/feedback/feedback.module.ts
 * @showLineNumbers
 */
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Feedback } from './feedback.entity';
import { FeedbackService } from './feedback.service';
import { FeedbackController } from './feedback.controller';

@Module({
  imports: [TypeOrmModule.forFeature([Feedback])],
  providers: [FeedbackService],
  controllers: [FeedbackController],
})
export class FeedbackModule {}
```

And register in `app.module.ts`:

```ts
imports: [
  TypeOrmModule.forRoot({
    type: 'sqlite',
    database: 'feedback.db',
    entities: [Feedback],
    synchronize: true,
  }),
  FeedbackModule,
],
```

Run it:

```bash
npm run start:dev
```

## 5.4 Frontend Widget (React)

A simple drop-in widget for either API:

```tsx
/**
 * @file: src/components/FeedbackWidget.tsx
 * @showLineNumbers
 */
import React, { useState } from 'react';

export const FeedbackWidget: React.FC<{ postSlug: string; apiUrl: string }> = ({
  postSlug,
  apiUrl,
}) => {
  const [helpful, setHelpful] = useState<boolean | null>(null);
  const [comment, setComment] = useState('');

  const submit = async () => {
    await fetch(`${apiUrl}/feedback`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ post_slug: postSlug, helpful, comment }),
    });
    setHelpful(null);
    setComment('');
    alert('Thanks for your feedback!');
  };

  return (
    <div>
      <p>Was this helpful?</p>
      <button onClick={() => setHelpful(true)}>Yes</button>
      <button onClick={() => setHelpful(false)}>No</button>
      <textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Leave a comment..."
      />
      <button onClick={submit}>Submit</button>
    </div>
  );
};
```

> Note: This is a bare bones component. The actual component used in your site should have styles and additional behaviors added to this component so that the user may interact with it correctly.

## 5.5 Summary

In this chapter, you:

* Designed a feedback schema.
* Built a **FastAPI backend**.
* Built the same in **NestJS**.
* Connected with a **React widget**.

Now you control your own data and can extend it however you want.

## 5.6 Exercise

1. Spin up either the **FastAPI** or **NestJS** backend.
2. Add the **FeedbackWidget** to a test blog page.
3. Submit votes + comments and verify they’re stored in your local SQLite DB.
4. (Optional) Try deploying to a free tier (Heroku, Vercel + Neon/Postgres, or Railway).

## 5.7 Next Step

In the next chapter, we’ll explore **Scaling the Feedback System**:

* Adding an **analytics dashboard**.
* Sending **notifications** (Slack, email).
* Running **sentiment analysis** on comments with ML.

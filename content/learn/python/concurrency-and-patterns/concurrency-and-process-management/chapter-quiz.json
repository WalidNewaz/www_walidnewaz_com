{
  "topic": "Concurrency and Process Management in Python",
  "questions": [
    {
      "question": "In Python's subprocess module, what does setting `check=True` in `subprocess.run(...)` do?",
      "options": [
        {
          "text": "It captures stdout and stderr automatically.",
          "correct": false,
          "explanation": "‚ö†Ô∏è `check=True` does not capture output. Use `capture_output=True` or specify `stdout`/`stderr` pipes for that."
        },
        {
          "text": "It raises a CalledProcessError if the process exits with a non-zero code.",
          "correct": true,
          "explanation": "üéâ With `check=True`, a non-zero return code causes `subprocess.CalledProcessError` to be raised."
        },
        {
          "text": "It runs the command through the system shell by default.",
          "correct": false,
          "explanation": "‚ö†Ô∏è Shell execution requires `shell=True`. `check=True` is unrelated to shell usage."
        },
        {
          "text": "It decodes bytes to text in the returned output.",
          "correct": false,
          "explanation": "‚ö†Ô∏è Decoding is controlled by `text=True` (or `encoding=`)."
        }
      ]
    },
    {
      "question": "True or False: `subprocess.Popen` is identical to `subprocess.run`, but with a different name.",
      "options": [
        {
          "text": "True",
          "correct": false,
          "explanation": "‚ö†Ô∏è `Popen` is a lower-level API for starting and interacting with a process; `run` is a convenience wrapper that waits for completion and returns a `CompletedProcess`."
        },
        {
          "text": "False",
          "correct": true,
          "explanation": "üéâ They are not identical. `run` starts a process, waits for it, and returns results; `Popen` allows more flexible, incremental interaction (streams, polling, manual wait)."
        }
      ]
    },
    {
      "question": "Which statement about `multiprocessing.Pool.map` is TRUE?",
      "options": [
        {
          "text": "It returns results in an arbitrary order, depending on which worker finishes first.",
          "correct": false,
          "explanation": "‚ö†Ô∏è `Pool.map` preserves input order. Use `imap_unordered` for out-of-order results."
        },
        {
          "text": "It preserves the order of the input iterable in the returned list.",
          "correct": true,
          "explanation": "üéâ `Pool.map(func, iterable)` collects results in the same order as the input."
        },
        {
          "text": "It cannot accept more tasks than the number of worker processes.",
          "correct": false,
          "explanation": "‚ö†Ô∏è It can queue many tasks; the pool schedules them to workers as they become free."
        },
        {
          "text": "It automatically shares Python objects by reference between processes.",
          "correct": false,
          "explanation": "‚ö†Ô∏è Processes do not share memory by default; arguments/results are pickled and sent between processes."
        }
      ]
    },
    {
      "question": "True or False: `multiprocessing.Manager().list()` returns a normal Python list that lives in each process's memory space independently.",
      "options": [
        {
          "text": "True",
          "correct": false,
          "explanation": "‚ö†Ô∏è A Manager returns a proxy to an object stored in a manager server process. Operations are proxied via IPC to a single shared object."
        },
        {
          "text": "False",
          "correct": true,
          "explanation": "üéâ It returns a proxy object; the actual list lives in the manager server process and is shared across processes via IPC."
        }
      ]
    },
    {
      "question": "When incrementing a shared counter using `multiprocessing.Value('i', 0)` across multiple processes, which approach is the safest to avoid lost updates?",
      "options": [
        {
          "text": "Increment the counter without any synchronization for best performance.",
          "correct": false,
          "explanation": "‚ö†Ô∏è Without synchronization, increments are not atomic and can be lost due to race conditions."
        },
        {
          "text": "Wrap each increment in `with counter.get_lock(): ...` or batch increments locally and add once under the lock.",
          "correct": true,
          "explanation": "üéâ Using the Value's lock (or batching plus a single locked update) prevents race conditions while balancing correctness and performance."
        },
        {
          "text": "Use `Pool.map` which automatically synchronizes shared state updates.",
          "correct": false,
          "explanation": "‚ö†Ô∏è `Pool.map` doesn‚Äôt synchronize arbitrary shared state; it just distributes function calls and gathers results."
        },
        {
          "text": "Switch to threads; the GIL prevents all race conditions.",
          "correct": false,
          "explanation": "‚ö†Ô∏è The GIL does not prevent logical race conditions; shared mutations still need synchronization even with threads."
        }
      ]
    }
  ]
}
{
  "topic": "Python Design Patterns",
  "questions": [
    {
      "question": "Which category of design patterns focuses on object creation?",
      "options": [
        {
          "text": "Structural",
          "correct": false,
          "explanation": "‚ö†Ô∏è Structural patterns are about composing objects and classes into larger structures, not object creation."
        },
        {
          "text": "Creational",
          "correct": true,
          "explanation": "üéâ Creational patterns abstract and encapsulate the process of object creation, making systems more flexible in deciding what, how, and when objects are created."
        },
        {
          "text": "Behavioral",
          "correct": false,
          "explanation": "‚ö†Ô∏è Behavioral patterns define how objects interact and communicate, not how they are created."
        },
        {
          "text": "Interactional",
          "correct": false,
          "explanation": "‚ö†Ô∏è There is no official 'Interactional' pattern category; this is a distractor."
        }
      ]
    },
    {
      "question": "The Adapter Pattern is most useful when:",
      "options": [
        {
          "text": "You want to enforce one global instance of a class.",
          "correct": false,
          "explanation": "‚ö†Ô∏è That describes the Singleton Pattern, not Adapter."
        },
        {
          "text": "You need incompatible APIs to work with a common interface.",
          "correct": true,
          "explanation": "üéâ The Adapter Pattern allows incompatible classes to work together by translating one interface into another expected by the client."
        },
        {
          "text": "You want to queue commands for later execution.",
          "correct": false,
          "explanation": "‚ö†Ô∏è That is the purpose of the Command Pattern."
        },
        {
          "text": "You need to define multiple execution strategies.",
          "correct": false,
          "explanation": "‚ö†Ô∏è That use case fits the Strategy Pattern, not Adapter."
        }
      ]
    },
    {
      "question": "Which pattern allows dynamic subscription and notification of events between objects?",
      "options": [
        {
          "text": "Observer",
          "correct": true,
          "explanation": "üéâ The Observer Pattern defines a one-to-many dependency, allowing observers to subscribe and receive notifications automatically when the subject changes state."
        },
        {
          "text": "Proxy",
          "correct": false,
          "explanation": "‚ö†Ô∏è Proxy provides a placeholder for another object to control access, not event subscriptions."
        },
        {
          "text": "Chain of Responsibility",
          "correct": false,
          "explanation": "‚ö†Ô∏è Chain of Responsibility passes a request along a chain of handlers until one handles it, not notifications."
        },
        {
          "text": "Factory Method",
          "correct": false,
          "explanation": "‚ö†Ô∏è Factory Method is about object creation, not subscriptions or notifications."
        }
      ]
    },
    {
      "question": "In the Strategy Pattern, algorithms are:",
      "options": [
        {
          "text": "Hardcoded into the client class.",
          "correct": false,
          "explanation": "‚ö†Ô∏è The point of Strategy is to decouple algorithms from clients so they aren‚Äôt hardcoded."
        },
        {
          "text": "Defined as interchangeable objects implementing a common interface.",
          "correct": true,
          "explanation": "üéâ The Strategy Pattern encapsulates algorithms in separate classes so they can be swapped at runtime without modifying the client."
        },
        {
          "text": "Only executed sequentially.",
          "correct": false,
          "explanation": "‚ö†Ô∏è The Strategy Pattern does not restrict execution to sequential order; strategies can encapsulate parallelism too."
        },
        {
          "text": "Always executed asynchronously.",
          "correct": false,
          "explanation": "‚ö†Ô∏è Execution mode depends on the strategy implementation; Strategy doesn‚Äôt enforce async behavior."
        }
      ]
    },
    {
      "question": "The Command Pattern helps with:",
      "options": [
        {
          "text": "Object creation without specifying concrete classes.",
          "correct": false,
          "explanation": "‚ö†Ô∏è That describes the Factory Method or Abstract Factory, not Command."
        },
        {
          "text": "Logging, undo/redo, and queuing actions.",
          "correct": true,
          "explanation": "üéâ The Command Pattern encapsulates requests as objects, making it easy to log, queue, and support undo/redo operations."
        },
        {
          "text": "Translating one interface into another.",
          "correct": false,
          "explanation": "‚ö†Ô∏è That is the Adapter Pattern, not Command."
        },
        {
          "text": "Structuring objects into trees.",
          "correct": false,
          "explanation": "‚ö†Ô∏è That is the Composite Pattern, not Command."
        }
      ]
    }
  ]
}
